import express from 'express'
import cors from 'cors'
import { spawn } from 'child_process'
import path from 'path'
import { fileURLToPath } from 'url'
import fs from 'fs'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const app = express()
const PORT = process.env.PORT || 3002
const isProduction = process.env.NODE_ENV === 'production'

// Determine frontend build path
const frontendPath = isProduction 
  ? path.join(__dirname, 'frontend', 'dist')
  : null

// CORS configuration - allow all origins in development, configure for production
const corsOptions = isProduction
  ? {
      origin: true, // Will be configured based on request in production
      credentials: true
    }
  : {
      origin: ['http://localhost:5173', 'http://127.0.0.1:5173'],
      credentials: true
    }

app.use(cors(corsOptions))
app.use(express.json({ limit: '50mb' }))

// Serve static frontend files in production
if (isProduction && frontendPath && fs.existsSync(frontendPath)) {
  console.log(`Serving frontend from: ${frontendPath}`)
  app.use(express.static(frontendPath))
  
  // Handle SPA routing - serve index.html for all non-API routes
  app.get('*', (req, res) => {
    if (!req.path.startsWith('/api')) {
      res.sendFile(path.join(frontendPath, 'index.html'))
    }
  })
}

// Store running processes
let currentProcess = null

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    processRunning: currentProcess !== null
  })
})

// API Routes

// Run Agent
app.post('/api/run-agent', (req, res) => {
  const { repoUrl, teamName, leaderName, token, openaiKey } = req.body

  // Token is now optional if gh CLI is available
  if (!repoUrl || !teamName || !leaderName) {
    return res.status(400).json({
      success: false,
      message: 'Missing required fields: repoUrl, teamName, leaderName'
    })
  }

  // Kill any existing process
  if (currentProcess) {
    try {
      currentProcess.kill('SIGTERM')
      setTimeout(() => {
        if (currentProcess) {
          try {
            currentProcess.kill('SIGKILL')
          } catch (e) { }
        }
      }, 2000)
    } catch (e) {
      console.error('Error killing process:', e)
    }
    currentProcess = null
  }

  try {
    const riftPath = path.join(__dirname, '..')

    // Escape strings for Python - handle undefined/null
    const escapeStr = (s) => {
      if (!s) return ''
      return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'")
    }

    const pythonCode = `
import sys
import json
import os
import traceback
import os

sys.path.insert(0, '${riftPath.replace(/\\/g, '\\\\')}')

# Set token if provided (optional)
token_str = '${escapeStr(token)}'
if token_str:
    os.environ['GITHUB_TOKEN'] = token_str
${openaiKey ? `os.environ['OPENAI_API_KEY'] = '${escapeStr(openaiKey)}'` : ''}

from rift.agent import RiftAgent
from rift.utils import check_gh_available, check_gh_authenticated, create_pr_with_gh

agent = RiftAgent(
    repo_url='${escapeStr(repoUrl)}',
    team_name='${escapeStr(teamName)}',
    leader_name='${escapeStr(leaderName)}',
    token='${escapeStr(token)}',
    ${openaiKey ? `openai_api_key='${escapeStr(openaiKey)}'` : ''}
)

try:
    result = agent.run_full_cycle()
    
    # If PR was not created (no token or failed), try using gh CLI as fallback
    if not result.get('pr_created'):
        print("No PR created by agent, trying gh CLI fallback...", flush=True)
        
        # Check if gh CLI is available and authenticated
        if check_gh_available() and check_gh_authenticated():
            print("gh CLI is available and authenticated, creating PR...", flush=True)
            
            # Build PR details
            branch_name = agent.branch_name
            pr_title = f"[AI Fix] {branch_name}"
            fixes_summary = "\\n".join(
                f"- {fix.get('bug_type', 'UNKNOWN')}: {fix.get('fix', 'No description')[:50]}... (line {fix.get('line', '?')})"
                for fix in result.get('fixes', [])
            )
            pr_body = f"""## Summary
AI-powered fixes for {len(result.get('fixes', []))} issues.

### Fixes Applied
{fixes_summary}

---
*Generated by RiftAgent AI*"""
            
            pr_number = create_pr_with_gh(
                repo_url='${escapeStr(repoUrl)}',
                branch_name=branch_name,
                title=pr_title,
                body=pr_body,
                base_branch="main"
            )
            
            if pr_number:
                result['pr_created'] = pr_number
                print(f"PR created via gh CLI: #{pr_number}", flush=True)
        else:
            print("gh CLI not available or not authenticated", flush=True)
    
    print('RESULT:' + json.dumps(result), flush=True)
except Exception as e:
    print('ERROR:' + str(e), flush=True)
    traceback.print_exc()
`

    // Sandboxed environment â€” only pass whitelisted vars, no host secrets
    const sandboxEnv = {
      PATH: process.env.PATH || '/usr/local/bin:/usr/bin:/bin',
      HOME: '/tmp',
      TMPDIR: '/tmp',
      LANG: process.env.LANG || 'en_US.UTF-8',
      PYTHONPATH: process.env.PYTHONPATH || '',
      GITHUB_TOKEN: token || '',
      ...(openaiKey ? { OPENAI_API_KEY: openaiKey } : {})
    }

    const pythonProcess = spawn('python3', ['-u', '-c', pythonCode], {
      cwd: riftPath,
      stdio: ['pipe', 'pipe', 'pipe'],
      env: sandboxEnv
    })

    currentProcess = pythonProcess

    let output = ''
    let errorOutput = ''

    // Set timeout - 15 minutes (large repos need time to clone and analyze)
    const timeout = setTimeout(() => {
      if (currentProcess) {
        console.log('Process timed out, killing...')
        pythonProcess.kill('SIGTERM')
        currentProcess = null
      }
    }, 15 * 60 * 1000)

    pythonProcess.stdout.on('data', (data) => {
      output += data.toString()
    })

    pythonProcess.stderr.on('data', (data) => {
      errorOutput += data.toString()
    })

    pythonProcess.on('error', (err) => {
      clearTimeout(timeout)
      currentProcess = null
      console.error('Process error:', err)
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          message: 'Failed to start agent: ' + err.message
        })
      }
    })

    pythonProcess.on('close', (code) => {
      clearTimeout(timeout)
      currentProcess = null

      // Look for RESULT in output
      const resultMatch = output.match(/RESULT:(\{.*\})/s)
      if (resultMatch) {
        try {
          const result = JSON.parse(resultMatch[1])
          return res.json({
            success: result.success,
            errorsDetected: result.errors_detected,
            fixesApplied: result.fixes_applied,
            prCreated: result.pr_created,
            error: result.error,
            fixes: result.fixes || []
          })
        } catch (e) {
          console.error('Parse result error:', e)
        }
      }

      // Check for ERROR
      if (output.includes('ERROR:')) {
        const errorMatch = output.match(/ERROR:(.*)/)
        return res.status(500).json({
          success: false,
          message: errorMatch ? errorMatch[1].trim() : 'Agent execution failed'
        })
      }

      // Success fallback
      res.json({
        success: code === 0 || !errorOutput,
        errorsDetected: 0,
        fixesApplied: 0,
        prCreated: null,
        output: output.substring(0, 1000)
      })
    })

  } catch (error) {
    console.error('Spawn error:', error)
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to start agent'
    })
  }
})

// Get status
app.get('/api/status', (req, res) => {
  res.json({
    running: currentProcess !== null,
    pid: currentProcess?.pid || null
  })
})

// Cancel running agent
app.post('/api/cancel', (req, res) => {
  if (currentProcess) {
    currentProcess.kill('SIGTERM')
    setTimeout(() => {
      if (currentProcess) {
        try {
          currentProcess.kill('SIGKILL')
        } catch (e) { }
        currentProcess = null
      }
    }, 1000)
    return res.json({ success: true, message: 'Agent cancelled' })
  }
  return res.json({ success: false, message: 'No agent running' })
})

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err)
})

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason)
})

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`RiftAgent API server running on http://localhost:${PORT}`)
  console.log(`Frontend should connect to: http://localhost:${PORT}`)
})

